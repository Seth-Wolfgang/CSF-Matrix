interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(1)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "1 / Redundancy"),
yaxis = list(title = "1 / Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(min(interpResult$z), max(interpResult$z), by = 0.1),
ticktext = seq(min(interpResult$z), max(interpResult$z), by = 0.1)
))
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(1)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "1 / Redundancy"),
yaxis = list(title = "1 / Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(0), max(interpResult$z), by = 0.1),
ticktext = seq(0, max(interpResult$z), by = 0.1)
))
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(1)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "1 / Redundancy"),
yaxis = list(title = "1 / Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(0, max(interpResult$z), by = 0.1),
ticktext = seq(0, max(interpResult$z), by = 0.1)
))
View(interpResult)
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(1)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "1 / Redundancy"),
yaxis = list(title = "1 / Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1),
ticktext = seq(min(sizeData$Ratio, max(sizeData$Ratio), by = 0.1)
))
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(1)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "1 / Redundancy"),
yaxis = list(title = "1 / Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1),
ticktext = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1)
))
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(1)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "Redundancy"),
yaxis = list(title = "Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1),
ticktext = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1)
))
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(100)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "Redundancy"),
yaxis = list(title = "Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1),
ticktext = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1)
))
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
View(sizeData)
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(100)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "Redundancy"),
yaxis = list(title = "Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1),
ticktext = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1)
))
setwd("~/vscode/CSF-Matrix/Benchmarking")
library(ggplot2)
#setwd("") # YOU WILL NEED TO CHANGE THIS, JUST COMMENT IT OUT AND PASTE YOUR OWN PATH TO timeDataFinal.csv
#data <- read.csv("timeDataFinal.csv") # or whatever you saved it as
#rawData <- read.csv("rawTimeDataFinal.csv")
sizeData <- read.csv("sizeData.csv")
#move annoying offset from reading in matrix number as rownames
#colnames(data) <- c(colnames(data)[-1], "")
# delete useless column
#data <- data[,-ncol(data)]
# Create a new column with grouped intervals
# Create a new column with grouped intervals, excluding NA values
# Calculate ratios
sizeData$Ratio <- sizeData$CSF2.Size / sizeData$CSF1.Size
sizeData$InverseRedundancy <- 1 / sizeData$Redundancy
sizeData$InverseSparsity <- ifelse(sizeData$Sparsity == 0, 1, 1 / sizeData$Sparsity)
gridData <- data.frame(InverseRedundancy = rep(xGrid, gridSize),
InverseSparsity = rep(yGrid, each = gridSize))
# Create the interpolated surface
# Interpolate the ratio values
interpResult <- interp(sizeData$InverseRedundancy, sizeData$InverseSparsity, sizeData$Ratio,
xo = xGrid, yo = yGrid, duplicate = "mean")
# Extract interpolated values
interpValues <- interpResult$z
# Create a custom color scale with a steeper gradient
colorScale <- colorRampPalette(c("#FF0000", "#FF3333", "#FF6666", "#FF9999",
"#FFCCCC", "#FFFFCC", "#FFFF99", "#FFFF66",
"#FFFF33", "#FFFF00", "#00FF00"))(100)
# Create a plotly surface plot using interpolated values and custom color scale
plot_ly(x = interpResult$x, y = interpResult$y, z = interpResult$z,
type = "surface", colorscale = colorScale) %>%
layout(scene = list(xaxis = list(title = "Redundancy"),
yaxis = list(title = "Sparsity"),
zaxis = list(title = "CSF2.Size / CSF1.Size")),
colorbar = list(
tickmode = "array",
tickvals = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1),
ticktext = seq(min(sizeData$Ratio), max(sizeData$Ratio), by = 0.1)
))
