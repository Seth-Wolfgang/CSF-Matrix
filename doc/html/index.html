<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CSF Matrix: Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CSF Matrix
   &#160;<span id="projectnumber">v1.0</span>
   </div>
   <div id="projectbrief">A sparse matrix compression library.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Overview </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#whatiscsf">What is CSF?</a></li>
<li class="level1"><a href="#compression">Compression Techniques</a></li>
<li class="level1"><a href="#levels">Compresion Levels</a></li>
</ul>
</div>
<div class="textblock"><h2>Compressed Spares Fiber (CSF) Matrix Package</h2>
<p><a href="https://github.com/Seth-Wolfgang/CSF-Matrix">Github Repo</a></p>
<p>Large amounts of data take time and money to store, process, and compress. As data grows exponentially, we need better, cheaper tools to store and process it.</p>
<p>The Compressed Sparse Fiber (CSF) format is a way to take advantage of naturally redundant data and store it in a usable way. CSF works very well with redundant data, so much so that preliminary testing shows that it can beat common alternative formats in memory footprint by as much as 50%. This implementation of CSF also has variable compression levels that give the user options to lower this footprint even further at a small performance cost.</p>
<p>CSF offers a novel solution to storing large amounts of data at little performance cost allowing otherwise bottlenecked systems to solve problems with large amounts of data.</p>
<h1><a class="anchor" id="whatiscsf"></a>
What is CSF?</h1>
<p>First lets define a Sparse Matrix. A Sparse Matrix is a matrix that has a number of zero entries such that this sparsity can be taken advantage of in some way, shape, or form. Here we focus on gaining compression from this sparsity.</p>
<p>Compressed Sparse Fiber is another way to store sparse data much like compressed sparse column (CSC) or coordinate format (COO). The way CSF works is that a matrix is first broken down by major order, most commonly by column, and then by fiber.</p>
<p>After getting an individual column from the original matrix we construct a number of fibers to represent the data in that column. Fibers are simply a value followed by the indices where that value occurs in the column. By doing this for each value we get a column represented by a number of these fibers and then doing this for each column we can store an entire matrix this way.</p>
<p><b>[Put a picture of CSF here plz skyler]</b></p>
<hr  />
<h1><a class="anchor" id="compression"></a>
Compression Techniques</h1>
<p>There are a few different ways in which CSF compresses data. The first is redundancy, with fibers alone being able to compress redudnant data up to 50% compared to CSC. The second is Positive Delta Encoding, which is a process which we apply to the indices of a fiber which encodes the distance between each index. The third way is through bytepacking, which is when we cast each fibers indices to the smallest data type that doesn't lose precision.</p>
<h4>Redundancy</h4>
<p>It's easy to see how redundancy can be taken advantage of when looking at CSC format. In this format each value and index must be listed once no matter the data, with a set of column pointers being used to delimit columns. However in CSF if a column has only a single value, it's only stored once and then all of the indices that value is located. This means that in the simplest case of a column 50 long of all ones, CSC needs to store 100 values where as CSF needs only to store 51, the 1 and all the indices.</p>
<p>Therefor in datasets that are highly redundant CSF mananges to not explicitly store a lot of values resulting in good compression ratios for this data. It is worth being said however that data that is almost completely unique however will cause this pendulum to swing in the other direction, causing worse compression in the worst case scenario since CSF has more overhead to organize the data than CSC.</p>
<h4>Positive Delta Endoding</h4>
<p>We use this to take the indices inside of a fiber and encode the distance between them. While this doesn't cause us to store any less values, it can take larger values and make them smaller. Such as for a 10,000 x 10,000 matrix near the end of a column the indices could be [..., 9,973, 9,979, 9,981, 9,991], each of these values requires a 16 byte data type to store whereas if we positive delta encode them into [..., 3, 6, 2, 10] the values get much smaller and could potentially fit into a smaller data type.</p>
<p>It should also be noted that this does make the data harder to traverse making it a tradeoff that isn't always worth it and will make data traversal slower, espeically if the data doesn't lend itself to the advantages of positive delta encoding.</p>
<h4>Bytepacking</h4>
<p>This is a process that takes all of the indices of a single fiber, finds the maximum value after positive delta encoding, and casts the indices to the smallest data type that doesn't lose precision. Such as if a user has a CSF matrix with indices stored in uint64_t yet no number exceedes 255. In this situation each fiber's indices would most likely be cast to a uint8_t saving 7 bytes per index. This is great for isolating outlier data from enforcing a large data type and in combination with positive delta encoding can result in even very large matrices being heavily conmpressed with very little wasted space in the indices.</p>
<p>As a side note, this as well makes the data somewhat more difficult to work with causing some degree of complication and slowdowns for data traversal but is often very much worth the savings.</p>
<hr  />
 <h1><a class="anchor" id="levels"></a>
Compresion Levels</h1>
<p>There are currently 3 compression levels to CSF.</p>
<p><em>Compression Level 1: CSC Storage Format</em></p>
<p>This is simply just a CSC matrix format. This is helpful for transitioning between deeper compression levels and back to a more workable format as many times CSC is far faster for certain algorithms. This also helps increase interoperability with other libraries and within CSF.</p>
<p><em>Compression Level 2: CSF</em></p>
<p>Level 2 is the baseline version of CSF without any of the fancy tricks and just implementing the storage format. This means it doesn't include positive delta encoding or bytepacking. This results in data that is more compressed if sufficiently redundant but also still traversable in reasonable times. This should be seen as the middle ground.</p>
<p><em>Compression Level 3: CSF + Positive Delta Encoding + Bytepacking</em></p>
<p>This is the compression level that will get the furthest compressed for most data, and very compressed for sparse redundant data. Each process squeezes out more and more bytes from the data and results in a very compressed matrix that doesn't have traversal speeds quite as fast as level 2. This level can be used if traversal speeds aren't as much of a factor or one is trying to use a dataset that would otherwise not fit in RAM without compression but still needs to be worked with. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 9 2023 15:20:40 for CSF Matrix by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
